# Refactoring plan

## "Outer" multiplex stuff

The current "many async blocks and an enum" event handling method causes functions to be annoyingly long-winded, on top of causing the Rust compiler to generate poor-quality code.

Instead, we should have `Arc<MultiplexState>`, which will have well-defined methods for state transitions, that is passed to a few looping tasks, such as `recv_msg_loop`, that handle events and call specific methods.

This also maximizes opportunity for concurrency.

One challenge for this approach is handling _reactions_ generated by the state, such as responses to hello packets. This can be done by having, say, the `process_msg` method return a list of generated events.

But this approach does not work for handling _actions_ that are entirely self-generated. So actions in general should instead be handled by passing a callback to the multiplex state. This callback should most likely be the sending end of a channel.

The final workflow looks like this:

- One loop that handles incoming messages and calls `process_msg` on the state
- Another loop that calls `tick_all()`, which ticks all the streams and returns the closest Instant. While ticking the streams, the callback channel is pushed into as needed.
- Another loop that drains the callback channel and handles things accordingly.
- Method for sending messages calls `send_outgoing` on the state directly, no channels

## Streams

The tricky thing here is the large number of events fired at a very fine-grained level.

Instead, we should have a KCP-style loop that calls a `tick()` function that goes through the `StreamState` and takes actions accordingly, in a non-blocking fashion.

The tricky part is avoiding the requirement to continually call `tick()` at a fixed interval (and wasting battery etc). This is by having `tick()` return an `Instant` that designates the next time it should be called.

The next tricky part, given this, is having `tick()` run immediately after an incoming event. This is done by the external loop also polling a `ManualResetEvent` or similar inside the `StreamState` in addition to the ticking timer.

There can be one huge loop at the multiplex level that simply loops through everything calling `tick()`. This saves on wakeups. On a busy server this just degenerates into calling `tick()` constantly (perhaps with a rate limit, like once per ms), but that's perfectly okay.
